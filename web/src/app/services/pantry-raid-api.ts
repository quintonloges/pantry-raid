//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.3.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAdminClient {
    ping(): Observable<FileResponse>;
    createIngredient(dto: IngredientCreateDto): Observable<IngredientDto>;
    updateIngredient(id: number, dto: IngredientUpdateDto): Observable<IngredientDto>;
    deleteIngredient(id: number): Observable<FileResponse>;
}

@Injectable()
export class AdminClient implements IAdminClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    ping(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/admin/ping";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPing(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPing(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPing(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createIngredient(dto: IngredientCreateDto): Observable<IngredientDto> {
        let url_ = this.baseUrl + "/api/admin/ingredients";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateIngredient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateIngredient(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IngredientDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IngredientDto>;
        }));
    }

    protected processCreateIngredient(response: HttpResponseBase): Observable<IngredientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IngredientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateIngredient(id: number, dto: IngredientUpdateDto): Observable<IngredientDto> {
        let url_ = this.baseUrl + "/api/admin/ingredients/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateIngredient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateIngredient(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IngredientDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IngredientDto>;
        }));
    }

    protected processUpdateIngredient(response: HttpResponseBase): Observable<IngredientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IngredientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteIngredient(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/admin/ingredients/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteIngredient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteIngredient(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteIngredient(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAdminIngredientGroupClient {
    getGroup(id: number): Observable<IngredientGroupDto>;
    updateGroup(id: number, dto: UpdateIngredientGroupDto): Observable<IngredientGroupDto>;
    deleteGroup(id: number): Observable<FileResponse>;
    createGroup(dto: CreateIngredientGroupDto): Observable<IngredientGroupDto>;
    setGroupItems(id: number, dto: SetIngredientGroupItemsDto): Observable<FileResponse>;
}

@Injectable()
export class AdminIngredientGroupClient implements IAdminIngredientGroupClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getGroup(id: number): Observable<IngredientGroupDto> {
        let url_ = this.baseUrl + "/api/admin/ingredient-groups/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IngredientGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IngredientGroupDto>;
        }));
    }

    protected processGetGroup(response: HttpResponseBase): Observable<IngredientGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IngredientGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateGroup(id: number, dto: UpdateIngredientGroupDto): Observable<IngredientGroupDto> {
        let url_ = this.baseUrl + "/api/admin/ingredient-groups/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IngredientGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IngredientGroupDto>;
        }));
    }

    protected processUpdateGroup(response: HttpResponseBase): Observable<IngredientGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IngredientGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteGroup(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/admin/ingredient-groups/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteGroup(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createGroup(dto: CreateIngredientGroupDto): Observable<IngredientGroupDto> {
        let url_ = this.baseUrl + "/api/admin/ingredient-groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IngredientGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IngredientGroupDto>;
        }));
    }

    protected processCreateGroup(response: HttpResponseBase): Observable<IngredientGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IngredientGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setGroupItems(id: number, dto: SetIngredientGroupItemsDto): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/admin/ingredient-groups/{id}/items";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetGroupItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetGroupItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSetGroupItems(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAdminRecipeClient {
    create(dto: CreateRecipeDto): Observable<RecipeDto>;
    setTags(id: number, dto: SetRecipeTagsDto): Observable<FileResponse>;
}

@Injectable()
export class AdminRecipeClient implements IAdminRecipeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(dto: CreateRecipeDto): Observable<RecipeDto> {
        let url_ = this.baseUrl + "/api/admin/recipes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecipeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecipeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RecipeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecipeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setTags(id: number, dto: SetRecipeTagsDto): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/admin/recipes/{id}/tags";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetTags(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSetTags(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAdminRecipeSourceClient {
    create(dto: CreateRecipeSourceDto): Observable<RecipeSourceDto>;
}

@Injectable()
export class AdminRecipeSourceClient implements IAdminRecipeSourceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(dto: CreateRecipeSourceDto): Observable<RecipeSourceDto> {
        let url_ = this.baseUrl + "/api/admin/recipe-sources";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecipeSourceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecipeSourceDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RecipeSourceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecipeSourceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAdminReferenceClient {
    createCuisine(dto: CreateReferenceDto): Observable<CuisineDto>;
    deleteCuisine(id: number): Observable<FileResponse>;
    createProtein(dto: CreateReferenceDto): Observable<ProteinDto>;
    deleteProtein(id: number): Observable<FileResponse>;
    createDietaryTag(dto: CreateReferenceDto): Observable<DietaryTagDto>;
    deleteDietaryTag(id: number): Observable<FileResponse>;
}

@Injectable()
export class AdminReferenceClient implements IAdminReferenceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    createCuisine(dto: CreateReferenceDto): Observable<CuisineDto> {
        let url_ = this.baseUrl + "/api/admin/reference/cuisines";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCuisine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCuisine(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CuisineDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CuisineDto>;
        }));
    }

    protected processCreateCuisine(response: HttpResponseBase): Observable<CuisineDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CuisineDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteCuisine(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/admin/reference/cuisines/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCuisine(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCuisine(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteCuisine(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createProtein(dto: CreateReferenceDto): Observable<ProteinDto> {
        let url_ = this.baseUrl + "/api/admin/reference/proteins";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProtein(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProtein(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProteinDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProteinDto>;
        }));
    }

    protected processCreateProtein(response: HttpResponseBase): Observable<ProteinDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProteinDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteProtein(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/admin/reference/proteins/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProtein(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProtein(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteProtein(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createDietaryTag(dto: CreateReferenceDto): Observable<DietaryTagDto> {
        let url_ = this.baseUrl + "/api/admin/reference/dietary-tags";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDietaryTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDietaryTag(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DietaryTagDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DietaryTagDto>;
        }));
    }

    protected processCreateDietaryTag(response: HttpResponseBase): Observable<DietaryTagDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DietaryTagDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteDietaryTag(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/admin/reference/dietary-tags/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDietaryTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDietaryTag(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteDietaryTag(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IScrapeClient {
    scrape(request: ScrapeRequestDto): Observable<ScrapeResultDto>;
}

@Injectable()
export class ScrapeClient implements IScrapeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    scrape(request: ScrapeRequestDto): Observable<ScrapeResultDto> {
        let url_ = this.baseUrl + "/api/admin/Scrape";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScrape(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScrape(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ScrapeResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ScrapeResultDto>;
        }));
    }

    protected processScrape(response: HttpResponseBase): Observable<ScrapeResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ScrapeResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAdminUnmappedIngredientClient {
    getUnmappedIngredients(status?: string | null | undefined): Observable<UnmappedIngredientDto[]>;
    resolveUnmappedIngredient(id: number, request: ResolveUnmappedIngredientRequest): Observable<FileResponse>;
    suggestUnmappedIngredient(id: number, request: SuggestUnmappedIngredientRequest): Observable<FileResponse>;
}

@Injectable()
export class AdminUnmappedIngredientClient implements IAdminUnmappedIngredientClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getUnmappedIngredients(status?: string | null | undefined): Observable<UnmappedIngredientDto[]> {
        let url_ = this.baseUrl + "/api/admin/unmapped-ingredients?";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnmappedIngredients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnmappedIngredients(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnmappedIngredientDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnmappedIngredientDto[]>;
        }));
    }

    protected processGetUnmappedIngredients(response: HttpResponseBase): Observable<UnmappedIngredientDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UnmappedIngredientDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    resolveUnmappedIngredient(id: number, request: ResolveUnmappedIngredientRequest): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/admin/unmapped-ingredients/{id}/resolve";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveUnmappedIngredient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveUnmappedIngredient(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processResolveUnmappedIngredient(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    suggestUnmappedIngredient(id: number, request: SuggestUnmappedIngredientRequest): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/admin/unmapped-ingredients/{id}/suggest";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSuggestUnmappedIngredient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSuggestUnmappedIngredient(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSuggestUnmappedIngredient(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IReferenceClient {
    getSources(): Observable<RecipeSourceDto[]>;
    getIngredients(query?: string | null | undefined): Observable<IngredientDto[]>;
    getCuisines(): Observable<CuisineDto[]>;
    getProteins(): Observable<ProteinDto[]>;
    getDietaryTags(): Observable<DietaryTagDto[]>;
}

@Injectable()
export class ReferenceClient implements IReferenceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getSources(): Observable<RecipeSourceDto[]> {
        let url_ = this.baseUrl + "/api/reference/sources";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSources(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSources(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RecipeSourceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RecipeSourceDto[]>;
        }));
    }

    protected processGetSources(response: HttpResponseBase): Observable<RecipeSourceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RecipeSourceDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getIngredients(query?: string | null | undefined): Observable<IngredientDto[]> {
        let url_ = this.baseUrl + "/api/reference/ingredients?";
        if (query !== undefined && query !== null)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIngredients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIngredients(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IngredientDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IngredientDto[]>;
        }));
    }

    protected processGetIngredients(response: HttpResponseBase): Observable<IngredientDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IngredientDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCuisines(): Observable<CuisineDto[]> {
        let url_ = this.baseUrl + "/api/reference/cuisines";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCuisines(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCuisines(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CuisineDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CuisineDto[]>;
        }));
    }

    protected processGetCuisines(response: HttpResponseBase): Observable<CuisineDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CuisineDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProteins(): Observable<ProteinDto[]> {
        let url_ = this.baseUrl + "/api/reference/proteins";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProteins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProteins(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProteinDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProteinDto[]>;
        }));
    }

    protected processGetProteins(response: HttpResponseBase): Observable<ProteinDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProteinDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDietaryTags(): Observable<DietaryTagDto[]> {
        let url_ = this.baseUrl + "/api/reference/dietary-tags";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDietaryTags(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDietaryTags(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DietaryTagDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DietaryTagDto[]>;
        }));
    }

    protected processGetDietaryTags(response: HttpResponseBase): Observable<DietaryTagDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DietaryTagDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISearchClient {
    search(request: SearchRequestDto): Observable<SearchResponseDto>;
}

@Injectable()
export class SearchClient implements ISearchClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    search(request: SearchRequestDto): Observable<SearchResponseDto> {
        let url_ = this.baseUrl + "/api/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SearchResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SearchResponseDto>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<SearchResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISubstitutionClient {
    getAllGroups(): Observable<SubstitutionGroupDto[]>;
    createGroup(request: CreateSubstitutionGroupRequest): Observable<SubstitutionGroupDto>;
    getGroupById(id: number): Observable<SubstitutionGroupDto>;
    deleteGroup(id: number): Observable<FileResponse>;
    createOption(groupId: number, request: CreateSubstitutionOptionRequest): Observable<SubstitutionOptionDto>;
    updateOption(id: number, request: UpdateSubstitutionOptionRequest): Observable<SubstitutionOptionDto>;
    deleteOption(id: number): Observable<FileResponse>;
    updateOptionIngredients(id: number, request: ReplaceSubstitutionIngredientsRequest): Observable<FileResponse>;
}

@Injectable()
export class SubstitutionClient implements ISubstitutionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAllGroups(): Observable<SubstitutionGroupDto[]> {
        let url_ = this.baseUrl + "/api/admin/substitutions/groups";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGroups(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubstitutionGroupDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubstitutionGroupDto[]>;
        }));
    }

    protected processGetAllGroups(response: HttpResponseBase): Observable<SubstitutionGroupDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubstitutionGroupDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createGroup(request: CreateSubstitutionGroupRequest): Observable<SubstitutionGroupDto> {
        let url_ = this.baseUrl + "/api/admin/substitutions/groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubstitutionGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubstitutionGroupDto>;
        }));
    }

    protected processCreateGroup(response: HttpResponseBase): Observable<SubstitutionGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubstitutionGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getGroupById(id: number): Observable<SubstitutionGroupDto> {
        let url_ = this.baseUrl + "/api/admin/substitutions/groups/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGroupById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubstitutionGroupDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubstitutionGroupDto>;
        }));
    }

    protected processGetGroupById(response: HttpResponseBase): Observable<SubstitutionGroupDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubstitutionGroupDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteGroup(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/admin/substitutions/groups/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteGroup(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createOption(groupId: number, request: CreateSubstitutionOptionRequest): Observable<SubstitutionOptionDto> {
        let url_ = this.baseUrl + "/api/admin/substitutions/groups/{groupId}/options";
        if (groupId === undefined || groupId === null)
            throw new globalThis.Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOption(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubstitutionOptionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubstitutionOptionDto>;
        }));
    }

    protected processCreateOption(response: HttpResponseBase): Observable<SubstitutionOptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubstitutionOptionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateOption(id: number, request: UpdateSubstitutionOptionRequest): Observable<SubstitutionOptionDto> {
        let url_ = this.baseUrl + "/api/admin/substitutions/options/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOption(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubstitutionOptionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubstitutionOptionDto>;
        }));
    }

    protected processUpdateOption(response: HttpResponseBase): Observable<SubstitutionOptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubstitutionOptionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteOption(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/admin/substitutions/options/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOption(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteOption(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateOptionIngredients(id: number, request: ReplaceSubstitutionIngredientsRequest): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/admin/substitutions/options/{id}/ingredients";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOptionIngredients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOptionIngredients(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateOptionIngredients(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUserIngredientsClient {
    getUserIngredients(): Observable<IngredientDto[]>;
    replaceUserIngredients(ingredientIds: number[]): Observable<FileResponse>;
}

@Injectable()
export class UserIngredientsClient implements IUserIngredientsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getUserIngredients(): Observable<IngredientDto[]> {
        let url_ = this.baseUrl + "/api/user/ingredients";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserIngredients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserIngredients(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IngredientDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IngredientDto[]>;
        }));
    }

    protected processGetUserIngredients(response: HttpResponseBase): Observable<IngredientDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IngredientDto.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    replaceUserIngredients(ingredientIds: number[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/user/ingredients";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ingredientIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceUserIngredients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceUserIngredients(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processReplaceUserIngredients(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IHealthClient {
    get(): Observable<HealthResponseDto>;
}

@Injectable()
export class HealthClient implements IHealthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    get(): Observable<HealthResponseDto> {
        let url_ = this.baseUrl + "/api/health";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HealthResponseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HealthResponseDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<HealthResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HealthResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IDbClient {
    ping(): Observable<FileResponse>;
}

@Injectable()
export class DbClient implements IDbClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    ping(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/db/ping";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPing(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPing(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPing(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAuthClient {
    register(model: RegisterRequest): Observable<FileResponse>;
    login(model: LoginRequest): Observable<FileResponse>;
    me(): Observable<FileResponse>;
    changePassword(model: ChangePasswordRequest): Observable<FileResponse>;
    deleteAccount(): Observable<FileResponse>;
}

@Injectable()
export class AuthClient implements IAuthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    register(model: RegisterRequest): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    login(model: LoginRequest): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    me(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/auth/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processMe(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changePassword(model: ChangePasswordRequest): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/auth/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteAccount(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/auth/account";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteAccount(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class IngredientDto implements IIngredientDto {
    id?: number;
    name?: string;
    slug?: string;
    aliases?: string[];
    category?: string | undefined;
    notes?: string | undefined;
    globalRecipeCount?: number;

    constructor(data?: IIngredientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            if (Array.isArray(_data["aliases"])) {
                this.aliases = [] as any;
                for (let item of _data["aliases"])
                    this.aliases!.push(item);
            }
            this.category = _data["category"];
            this.notes = _data["notes"];
            this.globalRecipeCount = _data["globalRecipeCount"];
        }
    }

    static fromJS(data: any): IngredientDto {
        data = typeof data === 'object' ? data : {};
        let result = new IngredientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        if (Array.isArray(this.aliases)) {
            data["aliases"] = [];
            for (let item of this.aliases)
                data["aliases"].push(item);
        }
        data["category"] = this.category;
        data["notes"] = this.notes;
        data["globalRecipeCount"] = this.globalRecipeCount;
        return data;
    }
}

export interface IIngredientDto {
    id?: number;
    name?: string;
    slug?: string;
    aliases?: string[];
    category?: string | undefined;
    notes?: string | undefined;
    globalRecipeCount?: number;
}

export class IngredientCreateDto implements IIngredientCreateDto {
    name?: string;
    aliases?: string[];
    category?: string | undefined;
    notes?: string | undefined;

    constructor(data?: IIngredientCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["aliases"])) {
                this.aliases = [] as any;
                for (let item of _data["aliases"])
                    this.aliases!.push(item);
            }
            this.category = _data["category"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): IngredientCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IngredientCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.aliases)) {
            data["aliases"] = [];
            for (let item of this.aliases)
                data["aliases"].push(item);
        }
        data["category"] = this.category;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IIngredientCreateDto {
    name?: string;
    aliases?: string[];
    category?: string | undefined;
    notes?: string | undefined;
}

export class IngredientUpdateDto implements IIngredientUpdateDto {
    name?: string;
    aliases?: string[];
    category?: string | undefined;
    notes?: string | undefined;

    constructor(data?: IIngredientUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["aliases"])) {
                this.aliases = [] as any;
                for (let item of _data["aliases"])
                    this.aliases!.push(item);
            }
            this.category = _data["category"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): IngredientUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IngredientUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.aliases)) {
            data["aliases"] = [];
            for (let item of this.aliases)
                data["aliases"].push(item);
        }
        data["category"] = this.category;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IIngredientUpdateDto {
    name?: string;
    aliases?: string[];
    category?: string | undefined;
    notes?: string | undefined;
}

export class IngredientGroupDto implements IIngredientGroupDto {
    id?: number;
    name?: string;
    description?: string | undefined;
    items?: IngredientGroupItemDto[];

    constructor(data?: IIngredientGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(IngredientGroupItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IngredientGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new IngredientGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IIngredientGroupDto {
    id?: number;
    name?: string;
    description?: string | undefined;
    items?: IngredientGroupItemDto[];
}

export class IngredientGroupItemDto implements IIngredientGroupItemDto {
    ingredientId?: number;
    name?: string;
    orderIndex?: number;

    constructor(data?: IIngredientGroupItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ingredientId = _data["ingredientId"];
            this.name = _data["name"];
            this.orderIndex = _data["orderIndex"];
        }
    }

    static fromJS(data: any): IngredientGroupItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new IngredientGroupItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ingredientId"] = this.ingredientId;
        data["name"] = this.name;
        data["orderIndex"] = this.orderIndex;
        return data;
    }
}

export interface IIngredientGroupItemDto {
    ingredientId?: number;
    name?: string;
    orderIndex?: number;
}

export class CreateIngredientGroupDto implements ICreateIngredientGroupDto {
    name?: string;
    description?: string | undefined;
    initialIngredientIds?: number[] | undefined;

    constructor(data?: ICreateIngredientGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["initialIngredientIds"])) {
                this.initialIngredientIds = [] as any;
                for (let item of _data["initialIngredientIds"])
                    this.initialIngredientIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateIngredientGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateIngredientGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.initialIngredientIds)) {
            data["initialIngredientIds"] = [];
            for (let item of this.initialIngredientIds)
                data["initialIngredientIds"].push(item);
        }
        return data;
    }
}

export interface ICreateIngredientGroupDto {
    name?: string;
    description?: string | undefined;
    initialIngredientIds?: number[] | undefined;
}

export class UpdateIngredientGroupDto implements IUpdateIngredientGroupDto {
    name?: string;
    description?: string | undefined;

    constructor(data?: IUpdateIngredientGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateIngredientGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateIngredientGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        return data;
    }
}

export interface IUpdateIngredientGroupDto {
    name?: string;
    description?: string | undefined;
}

export class SetIngredientGroupItemsDto implements ISetIngredientGroupItemsDto {
    ingredientIds?: number[];

    constructor(data?: ISetIngredientGroupItemsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ingredientIds"])) {
                this.ingredientIds = [] as any;
                for (let item of _data["ingredientIds"])
                    this.ingredientIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SetIngredientGroupItemsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetIngredientGroupItemsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ingredientIds)) {
            data["ingredientIds"] = [];
            for (let item of this.ingredientIds)
                data["ingredientIds"].push(item);
        }
        return data;
    }
}

export interface ISetIngredientGroupItemsDto {
    ingredientIds?: number[];
}

export class RecipeDto implements IRecipeDto {
    id?: number;
    title?: string;
    recipeSourceId?: number;
    sourceUrl?: string;
    shortDescription?: string | undefined;
    imageUrl?: string | undefined;
    totalTimeMinutes?: number | undefined;
    servings?: number | undefined;
    scrapeStatus?: string;
    ingredients?: RecipeIngredientDto[];
    cuisines?: CuisineDto[];
    proteins?: ProteinDto[];
    dietaryTags?: DietaryTagDto[];

    constructor(data?: IRecipeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.recipeSourceId = _data["recipeSourceId"];
            this.sourceUrl = _data["sourceUrl"];
            this.shortDescription = _data["shortDescription"];
            this.imageUrl = _data["imageUrl"];
            this.totalTimeMinutes = _data["totalTimeMinutes"];
            this.servings = _data["servings"];
            this.scrapeStatus = _data["scrapeStatus"];
            if (Array.isArray(_data["ingredients"])) {
                this.ingredients = [] as any;
                for (let item of _data["ingredients"])
                    this.ingredients!.push(RecipeIngredientDto.fromJS(item));
            }
            if (Array.isArray(_data["cuisines"])) {
                this.cuisines = [] as any;
                for (let item of _data["cuisines"])
                    this.cuisines!.push(CuisineDto.fromJS(item));
            }
            if (Array.isArray(_data["proteins"])) {
                this.proteins = [] as any;
                for (let item of _data["proteins"])
                    this.proteins!.push(ProteinDto.fromJS(item));
            }
            if (Array.isArray(_data["dietaryTags"])) {
                this.dietaryTags = [] as any;
                for (let item of _data["dietaryTags"])
                    this.dietaryTags!.push(DietaryTagDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RecipeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecipeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["recipeSourceId"] = this.recipeSourceId;
        data["sourceUrl"] = this.sourceUrl;
        data["shortDescription"] = this.shortDescription;
        data["imageUrl"] = this.imageUrl;
        data["totalTimeMinutes"] = this.totalTimeMinutes;
        data["servings"] = this.servings;
        data["scrapeStatus"] = this.scrapeStatus;
        if (Array.isArray(this.ingredients)) {
            data["ingredients"] = [];
            for (let item of this.ingredients)
                data["ingredients"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.cuisines)) {
            data["cuisines"] = [];
            for (let item of this.cuisines)
                data["cuisines"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.proteins)) {
            data["proteins"] = [];
            for (let item of this.proteins)
                data["proteins"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.dietaryTags)) {
            data["dietaryTags"] = [];
            for (let item of this.dietaryTags)
                data["dietaryTags"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IRecipeDto {
    id?: number;
    title?: string;
    recipeSourceId?: number;
    sourceUrl?: string;
    shortDescription?: string | undefined;
    imageUrl?: string | undefined;
    totalTimeMinutes?: number | undefined;
    servings?: number | undefined;
    scrapeStatus?: string;
    ingredients?: RecipeIngredientDto[];
    cuisines?: CuisineDto[];
    proteins?: ProteinDto[];
    dietaryTags?: DietaryTagDto[];
}

export class RecipeIngredientDto implements IRecipeIngredientDto {
    id?: number;
    ingredientId?: number | undefined;
    originalText?: string;
    quantity?: number | undefined;
    unit?: string | undefined;
    isOptional?: boolean;

    constructor(data?: IRecipeIngredientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ingredientId = _data["ingredientId"];
            this.originalText = _data["originalText"];
            this.quantity = _data["quantity"];
            this.unit = _data["unit"];
            this.isOptional = _data["isOptional"];
        }
    }

    static fromJS(data: any): RecipeIngredientDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecipeIngredientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ingredientId"] = this.ingredientId;
        data["originalText"] = this.originalText;
        data["quantity"] = this.quantity;
        data["unit"] = this.unit;
        data["isOptional"] = this.isOptional;
        return data;
    }
}

export interface IRecipeIngredientDto {
    id?: number;
    ingredientId?: number | undefined;
    originalText?: string;
    quantity?: number | undefined;
    unit?: string | undefined;
    isOptional?: boolean;
}

export class CuisineDto implements ICuisineDto {
    id?: number;
    name?: string;

    constructor(data?: ICuisineDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CuisineDto {
        data = typeof data === 'object' ? data : {};
        let result = new CuisineDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICuisineDto {
    id?: number;
    name?: string;
}

export class ProteinDto implements IProteinDto {
    id?: number;
    name?: string;

    constructor(data?: IProteinDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ProteinDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProteinDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IProteinDto {
    id?: number;
    name?: string;
}

export class DietaryTagDto implements IDietaryTagDto {
    id?: number;
    name?: string;

    constructor(data?: IDietaryTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DietaryTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new DietaryTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IDietaryTagDto {
    id?: number;
    name?: string;
}

export class CreateRecipeDto implements ICreateRecipeDto {
    title!: string;
    recipeSourceId!: number;
    sourceUrl!: string;
    sourceRecipeId?: string | undefined;
    shortDescription?: string | undefined;
    imageUrl?: string | undefined;
    totalTimeMinutes?: number | undefined;
    servings?: number | undefined;
    ingredients?: CreateRecipeIngredientDto[];

    constructor(data?: ICreateRecipeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.recipeSourceId = _data["recipeSourceId"];
            this.sourceUrl = _data["sourceUrl"];
            this.sourceRecipeId = _data["sourceRecipeId"];
            this.shortDescription = _data["shortDescription"];
            this.imageUrl = _data["imageUrl"];
            this.totalTimeMinutes = _data["totalTimeMinutes"];
            this.servings = _data["servings"];
            if (Array.isArray(_data["ingredients"])) {
                this.ingredients = [] as any;
                for (let item of _data["ingredients"])
                    this.ingredients!.push(CreateRecipeIngredientDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateRecipeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRecipeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["recipeSourceId"] = this.recipeSourceId;
        data["sourceUrl"] = this.sourceUrl;
        data["sourceRecipeId"] = this.sourceRecipeId;
        data["shortDescription"] = this.shortDescription;
        data["imageUrl"] = this.imageUrl;
        data["totalTimeMinutes"] = this.totalTimeMinutes;
        data["servings"] = this.servings;
        if (Array.isArray(this.ingredients)) {
            data["ingredients"] = [];
            for (let item of this.ingredients)
                data["ingredients"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ICreateRecipeDto {
    title: string;
    recipeSourceId: number;
    sourceUrl: string;
    sourceRecipeId?: string | undefined;
    shortDescription?: string | undefined;
    imageUrl?: string | undefined;
    totalTimeMinutes?: number | undefined;
    servings?: number | undefined;
    ingredients?: CreateRecipeIngredientDto[];
}

export class CreateRecipeIngredientDto implements ICreateRecipeIngredientDto {
    ingredientId?: number | undefined;
    originalText!: string;
    quantity?: number | undefined;
    unit?: string | undefined;
    isOptional?: boolean;

    constructor(data?: ICreateRecipeIngredientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ingredientId = _data["ingredientId"];
            this.originalText = _data["originalText"];
            this.quantity = _data["quantity"];
            this.unit = _data["unit"];
            this.isOptional = _data["isOptional"];
        }
    }

    static fromJS(data: any): CreateRecipeIngredientDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRecipeIngredientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ingredientId"] = this.ingredientId;
        data["originalText"] = this.originalText;
        data["quantity"] = this.quantity;
        data["unit"] = this.unit;
        data["isOptional"] = this.isOptional;
        return data;
    }
}

export interface ICreateRecipeIngredientDto {
    ingredientId?: number | undefined;
    originalText: string;
    quantity?: number | undefined;
    unit?: string | undefined;
    isOptional?: boolean;
}

export class SetRecipeTagsDto implements ISetRecipeTagsDto {
    cuisineIds?: number[];
    proteinIds?: number[];
    dietaryTagIds?: number[];

    constructor(data?: ISetRecipeTagsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["cuisineIds"])) {
                this.cuisineIds = [] as any;
                for (let item of _data["cuisineIds"])
                    this.cuisineIds!.push(item);
            }
            if (Array.isArray(_data["proteinIds"])) {
                this.proteinIds = [] as any;
                for (let item of _data["proteinIds"])
                    this.proteinIds!.push(item);
            }
            if (Array.isArray(_data["dietaryTagIds"])) {
                this.dietaryTagIds = [] as any;
                for (let item of _data["dietaryTagIds"])
                    this.dietaryTagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SetRecipeTagsDto {
        data = typeof data === 'object' ? data : {};
        let result = new SetRecipeTagsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cuisineIds)) {
            data["cuisineIds"] = [];
            for (let item of this.cuisineIds)
                data["cuisineIds"].push(item);
        }
        if (Array.isArray(this.proteinIds)) {
            data["proteinIds"] = [];
            for (let item of this.proteinIds)
                data["proteinIds"].push(item);
        }
        if (Array.isArray(this.dietaryTagIds)) {
            data["dietaryTagIds"] = [];
            for (let item of this.dietaryTagIds)
                data["dietaryTagIds"].push(item);
        }
        return data;
    }
}

export interface ISetRecipeTagsDto {
    cuisineIds?: number[];
    proteinIds?: number[];
    dietaryTagIds?: number[];
}

export class RecipeSourceDto implements IRecipeSourceDto {
    id?: number;
    name?: string;
    baseUrl?: string;
    scraperKey?: string | undefined;
    isActive?: boolean;

    constructor(data?: IRecipeSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.baseUrl = _data["baseUrl"];
            this.scraperKey = _data["scraperKey"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): RecipeSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecipeSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["baseUrl"] = this.baseUrl;
        data["scraperKey"] = this.scraperKey;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IRecipeSourceDto {
    id?: number;
    name?: string;
    baseUrl?: string;
    scraperKey?: string | undefined;
    isActive?: boolean;
}

export class CreateRecipeSourceDto implements ICreateRecipeSourceDto {
    name!: string;
    baseUrl!: string;
    scraperKey?: string | undefined;
    isActive?: boolean;

    constructor(data?: ICreateRecipeSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.baseUrl = _data["baseUrl"];
            this.scraperKey = _data["scraperKey"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateRecipeSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRecipeSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["baseUrl"] = this.baseUrl;
        data["scraperKey"] = this.scraperKey;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateRecipeSourceDto {
    name: string;
    baseUrl: string;
    scraperKey?: string | undefined;
    isActive?: boolean;
}

export class CreateReferenceDto implements ICreateReferenceDto {
    name!: string;

    constructor(data?: ICreateReferenceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateReferenceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReferenceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateReferenceDto {
    name: string;
}

export class ScrapeResultDto implements IScrapeResultDto {
    status?: ScrapeResultStatus;
    message?: string;
    recipeId?: number | undefined;

    constructor(data?: IScrapeResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.message = _data["message"];
            this.recipeId = _data["recipeId"];
        }
    }

    static fromJS(data: any): ScrapeResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScrapeResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["message"] = this.message;
        data["recipeId"] = this.recipeId;
        return data;
    }
}

export interface IScrapeResultDto {
    status?: ScrapeResultStatus;
    message?: string;
    recipeId?: number | undefined;
}

export enum ScrapeResultStatus {
    Success = 0,
    Skipped = 1,
    Failed = 2,
}

export class ScrapeRequestDto implements IScrapeRequestDto {
    url?: string;

    constructor(data?: IScrapeRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): ScrapeRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScrapeRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        return data;
    }
}

export interface IScrapeRequestDto {
    url?: string;
}

export class UnmappedIngredientDto implements IUnmappedIngredientDto {
    id?: number;
    recipeId?: number;
    recipeTitle?: string;
    recipeSourceId?: number;
    recipeSourceName?: string;
    originalText?: string;
    suggestedIngredientId?: number | undefined;
    suggestedIngredientName?: string | undefined;
    resolvedIngredientId?: number | undefined;
    resolvedIngredientName?: string | undefined;
    status?: UnmappedIngredientStatusDto;
    createdAt?: Date;

    constructor(data?: IUnmappedIngredientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.recipeId = _data["recipeId"];
            this.recipeTitle = _data["recipeTitle"];
            this.recipeSourceId = _data["recipeSourceId"];
            this.recipeSourceName = _data["recipeSourceName"];
            this.originalText = _data["originalText"];
            this.suggestedIngredientId = _data["suggestedIngredientId"];
            this.suggestedIngredientName = _data["suggestedIngredientName"];
            this.resolvedIngredientId = _data["resolvedIngredientId"];
            this.resolvedIngredientName = _data["resolvedIngredientName"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): UnmappedIngredientDto {
        data = typeof data === 'object' ? data : {};
        let result = new UnmappedIngredientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["recipeId"] = this.recipeId;
        data["recipeTitle"] = this.recipeTitle;
        data["recipeSourceId"] = this.recipeSourceId;
        data["recipeSourceName"] = this.recipeSourceName;
        data["originalText"] = this.originalText;
        data["suggestedIngredientId"] = this.suggestedIngredientId;
        data["suggestedIngredientName"] = this.suggestedIngredientName;
        data["resolvedIngredientId"] = this.resolvedIngredientId;
        data["resolvedIngredientName"] = this.resolvedIngredientName;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IUnmappedIngredientDto {
    id?: number;
    recipeId?: number;
    recipeTitle?: string;
    recipeSourceId?: number;
    recipeSourceName?: string;
    originalText?: string;
    suggestedIngredientId?: number | undefined;
    suggestedIngredientName?: string | undefined;
    resolvedIngredientId?: number | undefined;
    resolvedIngredientName?: string | undefined;
    status?: UnmappedIngredientStatusDto;
    createdAt?: Date;
}

export enum UnmappedIngredientStatusDto {
    New = "New",
    Suggested = "Suggested",
    Resolved = "Resolved",
}

export class ResolveUnmappedIngredientRequest implements IResolveUnmappedIngredientRequest {
    resolvedIngredientId?: number;

    constructor(data?: IResolveUnmappedIngredientRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resolvedIngredientId = _data["resolvedIngredientId"];
        }
    }

    static fromJS(data: any): ResolveUnmappedIngredientRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveUnmappedIngredientRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resolvedIngredientId"] = this.resolvedIngredientId;
        return data;
    }
}

export interface IResolveUnmappedIngredientRequest {
    resolvedIngredientId?: number;
}

export class SuggestUnmappedIngredientRequest implements ISuggestUnmappedIngredientRequest {
    suggestedIngredientId?: number;

    constructor(data?: ISuggestUnmappedIngredientRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.suggestedIngredientId = _data["suggestedIngredientId"];
        }
    }

    static fromJS(data: any): SuggestUnmappedIngredientRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SuggestUnmappedIngredientRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["suggestedIngredientId"] = this.suggestedIngredientId;
        return data;
    }
}

export interface ISuggestUnmappedIngredientRequest {
    suggestedIngredientId?: number;
}

export class SearchResponseDto implements ISearchResponseDto {
    results?: RecipeGroupDto[];
    cursor?: string | undefined;

    constructor(data?: ISearchResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(RecipeGroupDto.fromJS(item));
            }
            this.cursor = _data["cursor"];
        }
    }

    static fromJS(data: any): SearchResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item ? item.toJSON() : undefined as any);
        }
        data["cursor"] = this.cursor;
        return data;
    }
}

export interface ISearchResponseDto {
    results?: RecipeGroupDto[];
    cursor?: string | undefined;
}

export class RecipeGroupDto implements IRecipeGroupDto {
    missingCount?: number;
    recipes?: SearchResultRecipeDto[];

    constructor(data?: IRecipeGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.missingCount = _data["missingCount"];
            if (Array.isArray(_data["recipes"])) {
                this.recipes = [] as any;
                for (let item of _data["recipes"])
                    this.recipes!.push(SearchResultRecipeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RecipeGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new RecipeGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["missingCount"] = this.missingCount;
        if (Array.isArray(this.recipes)) {
            data["recipes"] = [];
            for (let item of this.recipes)
                data["recipes"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IRecipeGroupDto {
    missingCount?: number;
    recipes?: SearchResultRecipeDto[];
}

export class SearchResultRecipeDto implements ISearchResultRecipeDto {
    recipe?: RecipeDto;
    haveIngredients?: string[];
    missingIngredients?: string[];
    substitutionNotes?: string[];

    constructor(data?: ISearchResultRecipeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recipe = _data["recipe"] ? RecipeDto.fromJS(_data["recipe"]) : undefined as any;
            if (Array.isArray(_data["haveIngredients"])) {
                this.haveIngredients = [] as any;
                for (let item of _data["haveIngredients"])
                    this.haveIngredients!.push(item);
            }
            if (Array.isArray(_data["missingIngredients"])) {
                this.missingIngredients = [] as any;
                for (let item of _data["missingIngredients"])
                    this.missingIngredients!.push(item);
            }
            if (Array.isArray(_data["substitutionNotes"])) {
                this.substitutionNotes = [] as any;
                for (let item of _data["substitutionNotes"])
                    this.substitutionNotes!.push(item);
            }
        }
    }

    static fromJS(data: any): SearchResultRecipeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchResultRecipeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipe"] = this.recipe ? this.recipe.toJSON() : undefined as any;
        if (Array.isArray(this.haveIngredients)) {
            data["haveIngredients"] = [];
            for (let item of this.haveIngredients)
                data["haveIngredients"].push(item);
        }
        if (Array.isArray(this.missingIngredients)) {
            data["missingIngredients"] = [];
            for (let item of this.missingIngredients)
                data["missingIngredients"].push(item);
        }
        if (Array.isArray(this.substitutionNotes)) {
            data["substitutionNotes"] = [];
            for (let item of this.substitutionNotes)
                data["substitutionNotes"].push(item);
        }
        return data;
    }
}

export interface ISearchResultRecipeDto {
    recipe?: RecipeDto;
    haveIngredients?: string[];
    missingIngredients?: string[];
    substitutionNotes?: string[];
}

export class SearchRequestDto implements ISearchRequestDto {
    ingredientIds?: number[];
    filters?: SearchFiltersDto;
    allowSubstitutions?: boolean;
    cursor?: string | undefined;

    constructor(data?: ISearchRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ingredientIds"])) {
                this.ingredientIds = [] as any;
                for (let item of _data["ingredientIds"])
                    this.ingredientIds!.push(item);
            }
            this.filters = _data["filters"] ? SearchFiltersDto.fromJS(_data["filters"]) : undefined as any;
            this.allowSubstitutions = _data["allowSubstitutions"];
            this.cursor = _data["cursor"];
        }
    }

    static fromJS(data: any): SearchRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ingredientIds)) {
            data["ingredientIds"] = [];
            for (let item of this.ingredientIds)
                data["ingredientIds"].push(item);
        }
        data["filters"] = this.filters ? this.filters.toJSON() : undefined as any;
        data["allowSubstitutions"] = this.allowSubstitutions;
        data["cursor"] = this.cursor;
        return data;
    }
}

export interface ISearchRequestDto {
    ingredientIds?: number[];
    filters?: SearchFiltersDto;
    allowSubstitutions?: boolean;
    cursor?: string | undefined;
}

export class SearchFiltersDto implements ISearchFiltersDto {
    proteinId?: number | undefined;
    cuisineIds?: number[] | undefined;
    dietaryTagIds?: number[] | undefined;
    mustIncludeIngredientIds?: number[] | undefined;
    sourceIds?: number[] | undefined;

    constructor(data?: ISearchFiltersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.proteinId = _data["proteinId"];
            if (Array.isArray(_data["cuisineIds"])) {
                this.cuisineIds = [] as any;
                for (let item of _data["cuisineIds"])
                    this.cuisineIds!.push(item);
            }
            if (Array.isArray(_data["dietaryTagIds"])) {
                this.dietaryTagIds = [] as any;
                for (let item of _data["dietaryTagIds"])
                    this.dietaryTagIds!.push(item);
            }
            if (Array.isArray(_data["mustIncludeIngredientIds"])) {
                this.mustIncludeIngredientIds = [] as any;
                for (let item of _data["mustIncludeIngredientIds"])
                    this.mustIncludeIngredientIds!.push(item);
            }
            if (Array.isArray(_data["sourceIds"])) {
                this.sourceIds = [] as any;
                for (let item of _data["sourceIds"])
                    this.sourceIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SearchFiltersDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchFiltersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["proteinId"] = this.proteinId;
        if (Array.isArray(this.cuisineIds)) {
            data["cuisineIds"] = [];
            for (let item of this.cuisineIds)
                data["cuisineIds"].push(item);
        }
        if (Array.isArray(this.dietaryTagIds)) {
            data["dietaryTagIds"] = [];
            for (let item of this.dietaryTagIds)
                data["dietaryTagIds"].push(item);
        }
        if (Array.isArray(this.mustIncludeIngredientIds)) {
            data["mustIncludeIngredientIds"] = [];
            for (let item of this.mustIncludeIngredientIds)
                data["mustIncludeIngredientIds"].push(item);
        }
        if (Array.isArray(this.sourceIds)) {
            data["sourceIds"] = [];
            for (let item of this.sourceIds)
                data["sourceIds"].push(item);
        }
        return data;
    }
}

export interface ISearchFiltersDto {
    proteinId?: number | undefined;
    cuisineIds?: number[] | undefined;
    dietaryTagIds?: number[] | undefined;
    mustIncludeIngredientIds?: number[] | undefined;
    sourceIds?: number[] | undefined;
}

export class SubstitutionGroupDto implements ISubstitutionGroupDto {
    id?: number;
    targetIngredientId?: number;
    targetIngredientName?: string;
    options?: SubstitutionOptionDto[];

    constructor(data?: ISubstitutionGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.targetIngredientId = _data["targetIngredientId"];
            this.targetIngredientName = _data["targetIngredientName"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(SubstitutionOptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubstitutionGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubstitutionGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["targetIngredientId"] = this.targetIngredientId;
        data["targetIngredientName"] = this.targetIngredientName;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ISubstitutionGroupDto {
    id?: number;
    targetIngredientId?: number;
    targetIngredientName?: string;
    options?: SubstitutionOptionDto[];
}

export class SubstitutionOptionDto implements ISubstitutionOptionDto {
    id?: number;
    substitutionGroupId?: number;
    note?: string | undefined;
    ingredients?: SubstitutionOptionIngredientDto[];

    constructor(data?: ISubstitutionOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.substitutionGroupId = _data["substitutionGroupId"];
            this.note = _data["note"];
            if (Array.isArray(_data["ingredients"])) {
                this.ingredients = [] as any;
                for (let item of _data["ingredients"])
                    this.ingredients!.push(SubstitutionOptionIngredientDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubstitutionOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubstitutionOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["substitutionGroupId"] = this.substitutionGroupId;
        data["note"] = this.note;
        if (Array.isArray(this.ingredients)) {
            data["ingredients"] = [];
            for (let item of this.ingredients)
                data["ingredients"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ISubstitutionOptionDto {
    id?: number;
    substitutionGroupId?: number;
    note?: string | undefined;
    ingredients?: SubstitutionOptionIngredientDto[];
}

export class SubstitutionOptionIngredientDto implements ISubstitutionOptionIngredientDto {
    ingredientId?: number;
    ingredientName?: string;

    constructor(data?: ISubstitutionOptionIngredientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ingredientId = _data["ingredientId"];
            this.ingredientName = _data["ingredientName"];
        }
    }

    static fromJS(data: any): SubstitutionOptionIngredientDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubstitutionOptionIngredientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ingredientId"] = this.ingredientId;
        data["ingredientName"] = this.ingredientName;
        return data;
    }
}

export interface ISubstitutionOptionIngredientDto {
    ingredientId?: number;
    ingredientName?: string;
}

export class CreateSubstitutionGroupRequest implements ICreateSubstitutionGroupRequest {
    targetIngredientId!: number;

    constructor(data?: ICreateSubstitutionGroupRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetIngredientId = _data["targetIngredientId"];
        }
    }

    static fromJS(data: any): CreateSubstitutionGroupRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSubstitutionGroupRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetIngredientId"] = this.targetIngredientId;
        return data;
    }
}

export interface ICreateSubstitutionGroupRequest {
    targetIngredientId: number;
}

export class CreateSubstitutionOptionRequest implements ICreateSubstitutionOptionRequest {
    substitutionGroupId!: number;
    note?: string | undefined;
    ingredientIds?: number[];

    constructor(data?: ICreateSubstitutionOptionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.substitutionGroupId = _data["substitutionGroupId"];
            this.note = _data["note"];
            if (Array.isArray(_data["ingredientIds"])) {
                this.ingredientIds = [] as any;
                for (let item of _data["ingredientIds"])
                    this.ingredientIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateSubstitutionOptionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSubstitutionOptionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["substitutionGroupId"] = this.substitutionGroupId;
        data["note"] = this.note;
        if (Array.isArray(this.ingredientIds)) {
            data["ingredientIds"] = [];
            for (let item of this.ingredientIds)
                data["ingredientIds"].push(item);
        }
        return data;
    }
}

export interface ICreateSubstitutionOptionRequest {
    substitutionGroupId: number;
    note?: string | undefined;
    ingredientIds?: number[];
}

export class UpdateSubstitutionOptionRequest implements IUpdateSubstitutionOptionRequest {
    note?: string | undefined;

    constructor(data?: IUpdateSubstitutionOptionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): UpdateSubstitutionOptionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSubstitutionOptionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["note"] = this.note;
        return data;
    }
}

export interface IUpdateSubstitutionOptionRequest {
    note?: string | undefined;
}

export class ReplaceSubstitutionIngredientsRequest implements IReplaceSubstitutionIngredientsRequest {
    ingredientIds!: number[];

    constructor(data?: IReplaceSubstitutionIngredientsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.ingredientIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ingredientIds"])) {
                this.ingredientIds = [] as any;
                for (let item of _data["ingredientIds"])
                    this.ingredientIds!.push(item);
            }
        }
    }

    static fromJS(data: any): ReplaceSubstitutionIngredientsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ReplaceSubstitutionIngredientsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ingredientIds)) {
            data["ingredientIds"] = [];
            for (let item of this.ingredientIds)
                data["ingredientIds"].push(item);
        }
        return data;
    }
}

export interface IReplaceSubstitutionIngredientsRequest {
    ingredientIds: number[];
}

export class HealthResponseDto implements IHealthResponseDto {
    status?: string;

    constructor(data?: IHealthResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): HealthResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new HealthResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        return data;
    }
}

export interface IHealthResponseDto {
    status?: string;
}

export class RegisterRequest implements IRegisterRequest {
    email?: string;
    password?: string;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterRequest {
    email?: string;
    password?: string;
}

export class LoginRequest implements ILoginRequest {
    email?: string;
    password?: string;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginRequest {
    email?: string;
    password?: string;
}

export class ChangePasswordRequest implements IChangePasswordRequest {
    currentPassword?: string;
    newPassword?: string;

    constructor(data?: IChangePasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordRequest {
    currentPassword?: string;
    newPassword?: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}